<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pilot Planning Viewer - Traffic Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
            color: white;
            padding: 24px 32px;
        }
        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        .controls {
            padding: 24px 32px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            align-items: end;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        label {
            font-size: 12px;
            font-weight: 600;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        input, select {
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        input:focus, select:focus {
            outline: none;
            border-color: #1976d2;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            outline: none;
            transition: background 0.2s;
        }
        input[type="range"]:hover {
            background: #d0d0d0;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1976d2;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #1565c0;
            transform: scale(1.1);
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1976d2;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #1565c0;
            transform: scale(1.1);
        }
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }
        .chart-section {
            padding: 24px 32px;
            border-right: 1px solid #e0e0e0;
        }
        .map-section {
            padding: 0;
            position: relative;
        }
        #airportMap {
            width: 100%;
            height: 600px;
        }
        .chart-container {
            margin-bottom: 32px;
        }
        .chart-container h3 {
            font-size: 18px;
            color: #333;
            margin-bottom: 16px;
            font-weight: 600;
        }
        .chart-wrapper {
            position: relative;
            height: 400px;
        }
        .info-panel {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 6px;
            margin-bottom: 24px;
        }
        .info-panel h4 {
            font-size: 14px;
            color: #1976d2;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e0e0e0;
            font-size: 14px;
        }
        .info-row:last-child {
            border-bottom: none;
        }
        .info-label {
            color: #666;
            font-weight: 500;
        }
        .info-value {
            color: #333;
            font-weight: 600;
        }
        .highlight {
            background: #e3f2fd;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .matched-days {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 6px;
            margin-top: 24px;
            max-height: 300px;
            overflow-y: auto;
        }
        .matched-days h4 {
            font-size: 14px;
            color: #1976d2;
            margin-bottom: 12px;
            font-weight: 600;
        }
        .matched-day {
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .matched-day:hover {
            border-color: #1976d2;
            background: #f0f7ff;
        }
        .matched-day.selected {
            border-color: #1976d2;
            background: #e3f2fd;
        }
        .matched-day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .matched-day-date {
            font-weight: 600;
            color: #333;
        }
        .matched-day-score {
            font-size: 12px;
            color: #666;
            background: #e0e0e0;
            padding: 2px 8px;
            border-radius: 4px;
        }
        .matched-day-details {
            font-size: 12px;
            color: #666;
        }
        .trace-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            overflow-y: auto;
        }
        .trace-modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .trace-modal-content {
            background: white;
            border-radius: 8px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            margin: 20px;
            display: flex;
            flex-direction: column;
        }
        .trace-modal-header {
            padding: 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .trace-modal-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        .trace-modal-close {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .trace-modal-close:hover {
            color: #000;
        }
        .trace-modal-body {
            padding: 20px;
            flex: 1;
            overflow: auto;
        }
        #traceMap {
            width: 100%;
            height: 600px;
            border-radius: 4px;
        }
        .trace-loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .trace-error {
            padding: 20px;
            color: #d32f2f;
            background: #ffebee;
            border-radius: 4px;
        }
        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr;
            }
            .chart-section {
                border-right: none;
                border-bottom: 1px solid #e0e0e0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Pilot Planning Viewer</h1>
            <p>Plan your arrival by analyzing historical traffic patterns</p>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label for="airportSelect">Destination Airport</label>
                <select id="airportSelect">
                    <option value="KORD" selected>KORD - Chicago O'Hare</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="arrivalDate">Arrival Date</label>
                <input type="date" id="arrivalDate">
            </div>
            
            <div class="control-group" style="grid-column: span 2;">
                <label for="arrivalTime">Arrival Time (Local)</label>
                <div style="display: flex; align-items: center; gap: 16px;">
                    <div style="flex: 1; position: relative;">
                        <input type="range" id="arrivalTimeSlider" min="0" max="95" step="1" 
                               style="width: 100%; height: 8px; border-radius: 4px; background: #e0e0e0; outline: none; cursor: pointer; -webkit-appearance: none;">
                        <div id="timeSliderLabels" style="display: flex; justify-content: space-between; margin-top: 4px; font-size: 11px; color: #666;">
                            <span>00:00</span>
                            <span>06:00</span>
                            <span>12:00</span>
                            <span>18:00</span>
                            <span>23:45</span>
                        </div>
                    </div>
                    <div id="arrivalTimeDisplay" style="min-width: 80px; text-align: center; font-size: 18px; font-weight: 600; color: #1976d2; padding: 8px 16px; background: #e3f2fd; border-radius: 6px;">
                        00:00
                    </div>
                    <input type="hidden" id="arrivalTime" value="00:00">
                </div>
                <div style="margin-top: 8px; font-size: 12px; color: #666; font-style: italic;">
                    Click on the timeline chart below to select a time, or use the slider above
                </div>
            </div>
            
            <div class="control-group">
                <label for="weatherScenario">Weather Scenario</label>
                <select id="weatherScenario">
                    <option value="clear">Clear (>3 miles)</option>
                    <option value="reduced">Reduced Visibility (1-3 miles)</option>
                    <option value="low">Low Visibility (<1 mile)</option>
                    <option value="custom">Custom</option>
                </select>
            </div>
            
            <div class="control-group" id="customWeatherGroup" style="display: none;">
                <label for="customVisibility">Visibility (miles)</label>
                <input type="number" id="customVisibility" min="0" max="10" step="0.1" value="2.0">
            </div>
            
            <div class="control-group">
                <button id="findSimilarDays" style="padding: 10px 20px; background: #1976d2; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                    Find Similar Days
                </button>
            </div>
        </div>
        
        <div class="content">
            <div class="chart-section">
                <div class="info-panel" id="infoPanel" style="display: none;">
                    <h4>Traffic Forecast</h4>
                    <div class="info-row">
                        <span class="info-label">Day of Week:</span>
                        <span class="info-value" id="dayOfWeek">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Expected Aircraft (50nm threshold):</span>
                        <span class="info-value" id="expectedCount">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Time Slot:</span>
                        <span class="info-value" id="timeSlot">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Sample Size:</span>
                        <span class="info-value" id="sampleSize">-</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Data Period:</span>
                        <span class="info-value" id="dataPeriod">-</span>
                    </div>
                </div>
                
                <div class="chart-container">
                    <h3 id="chartTitle">Historical Traffic Pattern</h3>
                    <div class="chart-wrapper">
                        <canvas id="trafficChart"></canvas>
                    </div>
                </div>
                
                <div class="matched-days" id="matchedDays" style="display: none;">
                    <h4>Similar Historical Days</h4>
                    <div id="matchedDaysExplanation" style="font-size: 12px; color: #666; margin-bottom: 12px; font-style: italic;">
                        Days are matched based on weather conditions at your selected arrival time slot. A day may have different weather at other times.
                    </div>
                    <div id="matchedDaysList"></div>
                </div>
            </div>
            
            <div class="map-section">
                <div id="scatterChartContainer" style="padding: 24px;">
                    <h3 id="scatterChartTitle" style="font-size: 18px; color: #333; margin-bottom: 16px; font-weight: 600;">Approach Timings - Select a Matched Day</h3>
                    <div class="chart-wrapper" style="position: relative; height: 500px;">
                        <canvas id="scatterChart"></canvas>
                    </div>
                    <div id="visibilityChartContainer" style="margin-top: 32px; display: none;">
                        <h3 id="visibilityChartTitle" style="font-size: 18px; color: #333; margin-bottom: 16px; font-weight: 600;">Visibility Over Time</h3>
                        <div class="chart-wrapper" style="position: relative; height: 300px;">
                            <canvas id="visibilityChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="trace-modal" id="traceModal">
        <div class="trace-modal-content">
            <div class="trace-modal-header">
                <div class="trace-modal-title" id="traceModalTitle">Flight Trace</div>
                <button class="trace-modal-close" onclick="closeTraceModal()">&times;</button>
            </div>
            <div class="trace-modal-body">
                <div id="traceLoading" class="trace-loading" style="display: none;">Loading trace...</div>
                <div id="traceError" class="trace-error" style="display: none;"></div>
                <div id="traceMap"></div>
            </div>
        </div>
    </div>

    <script>
        const airportData = {
            KORD: {
                name: "Chicago O'Hare International",
                code: "KORD",
                position: [41.9786, -87.9048],
                runways: [
                    { name: "4L", threshold: [41.9786, -87.9048], heading: 40 },
                    { name: "4R", threshold: [41.9800, -87.9020], heading: 40 },
                    { name: "9L", threshold: [41.9850, -87.9200], heading: 90 },
                    { name: "9C", threshold: [41.9870, -87.9150], heading: 90 },
                    { name: "9R", threshold: [41.9890, -87.9100], heading: 90 },
                    { name: "10L", threshold: [41.9920, -87.9050], heading: 100 },
                    { name: "10C", threshold: [41.9940, -87.9000], heading: 100 },
                    { name: "10R", threshold: [41.9960, -87.8950], heading: 100 }
                ]
            },
            KLAX: {
                name: "Los Angeles International",
                code: "KLAX",
                position: [33.9416, -118.4085],
                runways: [
                    { name: "24R", threshold: [33.9416, -118.4085], heading: 243 },
                    { name: "24L", threshold: [33.9493, -118.4071], heading: 243 },
                    { name: "25R", threshold: [33.9364, -118.4159], heading: 253 },
                    { name: "25L", threshold: [33.9441, -118.4145], heading: 253 }
                ]
            },
            KSFO: {
                name: "San Francisco International",
                code: "KSFO",
                position: [37.6213, -122.3790],
                runways: [
                    { name: "28R", threshold: [37.6213, -122.3790], heading: 283 },
                    { name: "28L", threshold: [37.6158, -122.3575], heading: 283 },
                    { name: "01R", threshold: [37.6067, -122.3582], heading: 13 },
                    { name: "01L", threshold: [37.6122, -122.3797], heading: 13 }
                ]
            },
            KLGA: {
                name: "LaGuardia Airport",
                code: "KLGA",
                position: [40.7769, -73.8740],
                runways: [
                    { name: "04", threshold: [40.7769, -73.8740], heading: 40 },
                    { name: "13", threshold: [40.7753, -73.8694], heading: 130 }
                ]
            },
            KJFK: {
                name: "John F. Kennedy International",
                code: "KJFK",
                position: [40.6398, -73.7789],
                runways: [
                    { name: "22L", threshold: [40.6398, -73.7789], heading: 223 }
                ]
            }
        };

        let trafficChart = null;
        let scatterChart = null;
        let visibilityChart = null;
        let currentBaselineData = null;
        let currentWeatherPatterns = null;
        let selectedMatchedDay = null;
        let arrivalZonePluginRegistered = false;
        let traceMap = null;
        let traceMapLayer = null;
        let currentChartAlignment = null;

        const arrivalZonePlugin = {
            id: 'arrivalZone',
            afterDraw: (chart) => {
                const zoneData = chart.options.plugins?.arrivalZone;
                if (!zoneData || zoneData.startIndex < 0 || zoneData.endIndex < 0) {
                    return;
                }

                if (chart.config.type !== 'line') {
                    return;
                }

                const { ctx, chartArea, scales } = chart;
                const { startIndex, endIndex, centerIndex } = zoneData;
                const xScale = scales.x;
                const yScale = scales.y;

                const startX = xScale.getPixelForValue(startIndex - 0.5);
                const endX = xScale.getPixelForValue(endIndex + 0.5);
                const centerX = xScale.getPixelForValue(centerIndex);
                const topY = chartArea.top;
                const bottomY = chartArea.bottom;

                if (!isFinite(startX) || !isFinite(endX) || !isFinite(centerX) || !isFinite(topY) || !isFinite(bottomY)) {
                    return;
                }

                ctx.save();
                
                const gradient = ctx.createLinearGradient(startX, topY, endX, topY);
                gradient.addColorStop(0, 'rgba(255, 87, 34, 0.08)');
                gradient.addColorStop(0.3, 'rgba(255, 87, 34, 0.15)');
                gradient.addColorStop(0.5, 'rgba(255, 87, 34, 0.25)');
                gradient.addColorStop(0.7, 'rgba(255, 87, 34, 0.15)');
                gradient.addColorStop(1, 'rgba(255, 87, 34, 0.08)');

                ctx.fillStyle = gradient;
                ctx.fillRect(startX, topY, endX - startX, bottomY - topY);

                ctx.strokeStyle = 'rgba(255, 87, 34, 0.4)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(startX, topY, endX - startX, bottomY - topY);

                ctx.strokeStyle = 'rgba(255, 87, 34, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(centerX, topY);
                ctx.lineTo(centerX, bottomY);
                ctx.stroke();

                ctx.restore();
            }
        };


        function getDayOfWeekName(date) {
            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            let dateObj;
            if (typeof date === 'string') {
                const [year, month, day] = date.split('-').map(Number);
                dateObj = new Date(year, month - 1, day);
            } else if (date instanceof Date) {
                dateObj = date;
            } else {
                dateObj = new Date(date);
            }
            return days[dateObj.getDay()];
        }

        function formatTimeSlot(timeStr) {
            return timeStr;
        }

        function roundToNearestQuarterHour(date) {
            const minutes = date.getMinutes();
            const roundedMinutes = Math.round(minutes / 15) * 15;
            const roundedDate = new Date(date);
            roundedDate.setMinutes(roundedMinutes);
            roundedDate.setSeconds(0);
            roundedDate.setMilliseconds(0);
            return roundedDate;
        }

        function formatTime(dateOrTimeStr) {
            if (typeof dateOrTimeStr === 'string') {
                return dateOrTimeStr;
            }
            if (dateOrTimeStr instanceof Date) {
                const hours = dateOrTimeStr.getHours().toString().padStart(2, '0');
                const minutes = dateOrTimeStr.getMinutes().toString().padStart(2, '0');
                return `${hours}:${minutes}`;
            }
            return String(dateOrTimeStr);
        }

        function getTimeSlotKey(dateOrTimeStr) {
            return formatTime(dateOrTimeStr);
        }

        async function loadBaselineData(airportCode) {
            try {
                const response = await fetch(`cache/${airportCode}/overall/baseline.json`);
                if (!response.ok) {
                    throw new Error(`Failed to load data for ${airportCode}`);
                }
                const data = await response.json();
                currentBaselineData = data;
                return data;
            } catch (error) {
                console.error('Error loading baseline data:', error);
                return null;
            }
        }

        async function loadWeatherPatterns(airportCode) {
            try {
                const response = await fetch(`cache/${airportCode}/2024-2025/weather-patterns.json`);
                if (!response.ok) {
                    throw new Error(`Failed to load weather patterns for ${airportCode}`);
                }
                const data = await response.json();
                currentWeatherPatterns = data;
                return data;
            } catch (error) {
                console.error('Error loading weather patterns:', error);
                return null;
            }
        }

        function categorizeVisibility(visibilitySm) {
            if (visibilitySm === null || visibilitySm === undefined || isNaN(visibilitySm)) {
                return 'unknown';
            }
            if (visibilitySm < 1) {
                return 'low';
            }
            if (visibilitySm < 3) {
                return 'reduced';
            }
            return 'clear';
        }

        async function getVisibilityAtTimeSlot(date, timeSlot, airportCode) {
            const [year] = date.split('-');
            try {
                const metarPath = `cache/metar/${airportCode}/${airportCode}_${year}.json`;
                const response = await fetch(metarPath);
                if (!response.ok) {
                    return null;
                }
                const metarData = await response.json();
                if (!metarData || !metarData.records) {
                    return null;
                }

                const season = getSeason(date, airportCode, year);
                const offsets = {
                    KORD: { winter: -6, summer: -5 },
                    KLGA: { winter: -5, summer: -4 },
                    KJFK: { winter: -5, summer: -4 },
                    KLAX: { winter: -8, summer: -7 },
                    KSFO: { winter: -8, summer: -7 },
                };
                const offset = offsets[airportCode] || { winter: -6, summer: -5 };
                const offsetHours = season === 'summer' ? offset.summer : offset.winter;

                const [slotHour, slotMin] = timeSlot.split(':').map(Number);
                const visibilities = [];

                for (const record of metarData.records) {
                    if (!record.valid || record.visibility_sm_v === null || record.visibility_sm_v === undefined) {
                        continue;
                    }

                    let recordDate;
                    if (typeof record.valid === 'string') {
                        let dateStr = record.valid;
                        if (!dateStr.includes('T')) {
                            dateStr = dateStr.replace(/^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})$/, '$1T$2');
                        }
                        if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('-', 10)) {
                            dateStr += 'Z';
                        }
                        recordDate = new Date(dateStr);
                    } else {
                        recordDate = new Date(record.valid);
                    }

                    if (isNaN(recordDate.getTime())) continue;

                    const utcTimestamp = recordDate.getTime();
                    const localTimestamp = utcTimestamp + offsetHours * 3600 * 1000;
                    const localDateObj = new Date(localTimestamp);
                    const recordLocalDateStr = localDateObj.toISOString().split('T')[0];

                    if (recordLocalDateStr !== date) {
                        continue;
                    }

                    const localHours = localDateObj.getUTCHours();
                    const localMinutes = localDateObj.getUTCMinutes();
                    const recordSlotMin = Math.floor(localMinutes / 15) * 15;
                    const recordSlot = `${String(localHours).padStart(2, '0')}:${String(recordSlotMin).padStart(2, '0')}`;

                    if (recordSlot === timeSlot) {
                        visibilities.push(record.visibility_sm_v);
                    }
                }

                if (visibilities.length === 0) {
                    return null;
                }

                return visibilities.reduce((a, b) => a + b, 0) / visibilities.length;
            } catch (error) {
                console.warn(`Error loading visibility for ${date} at ${timeSlot}:`, error);
                return null;
            }
        }

        async function findMatchingDays(weatherScenario, arrivalTime, customVisibility) {
            if (!currentWeatherPatterns || !currentWeatherPatterns.patterns) {
                return [];
            }

            const airportCode = document.getElementById('airportSelect').value;
            const patterns = currentWeatherPatterns.patterns;
            const [arrivalHour, arrivalMin] = arrivalTime.split(':').map(Number);
            const arrivalSlot = `${String(arrivalHour).padStart(2, '0')}:${String(Math.floor(arrivalMin / 15) * 15).padStart(2, '0')}`;
            
            let targetCategory = weatherScenario;
            let targetVisibilityMin = null;
            let targetVisibilityMax = null;
            
            if (weatherScenario === 'custom') {
                const vis = parseFloat(customVisibility) || 3;
                if (vis < 1) {
                    targetCategory = 'low';
                    targetVisibilityMin = 0;
                    targetVisibilityMax = 1;
                } else if (vis < 3) {
                    targetCategory = 'reduced';
                    targetVisibilityMin = 1;
                    targetVisibilityMax = 3;
                } else {
                    targetCategory = 'clear';
                    targetVisibilityMin = 3;
                    targetVisibilityMax = Infinity;
                }
            } else {
                if (targetCategory === 'clear') {
                    targetVisibilityMin = 3;
                    targetVisibilityMax = Infinity;
                } else if (targetCategory === 'reduced') {
                    targetVisibilityMin = 1;
                    targetVisibilityMax = 3;
                } else if (targetCategory === 'low') {
                    targetVisibilityMin = 0;
                    targetVisibilityMax = 1;
                }
            }

            const categoryPatterns = patterns.visibility[targetCategory];
            if (!categoryPatterns) {
                return [];
            }

            const timeSlotPatterns = categoryPatterns.byTimeSlot[arrivalSlot];
            if (!timeSlotPatterns || !timeSlotPatterns.days) {
                return [];
            }

            const matches = [];
            for (const date of timeSlotPatterns.days) {
                const actualVisibility = await getVisibilityAtTimeSlot(date, arrivalSlot, airportCode);
                
                if (actualVisibility === null) {
                    continue;
                }

                const actualCategory = categorizeVisibility(actualVisibility);
                if (actualCategory !== targetCategory) {
                    continue;
                }

                if (targetVisibilityMin !== null && targetVisibilityMax !== null) {
                    if (actualVisibility < targetVisibilityMin || actualVisibility >= targetVisibilityMax) {
                        continue;
                    }
                }

                const event = patterns.events.find(e => e.date === date);
                matches.push({
                    date,
                    score: 100,
                    event: event || null,
                    visibility: actualVisibility,
                    visibilityCategory: actualCategory,
                    timeSlot: arrivalSlot,
                });
            }

            matches.sort((a, b) => {
                if (a.event && !b.event) return -1;
                if (!a.event && b.event) return 1;
                return a.date.localeCompare(b.date);
            });

            return matches.slice(0, 10);
        }

        function displayMatchedDays(matches) {
            const container = document.getElementById('matchedDays');
            const list = document.getElementById('matchedDaysList');
            
            if (matches.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            list.innerHTML = '';

            const arrivalTime = document.getElementById('arrivalTime').value;
            const [arrivalHour, arrivalMin] = arrivalTime.split(':').map(Number);
            const arrivalSlot = `${String(arrivalHour).padStart(2, '0')}:${String(Math.floor(arrivalMin / 15) * 15).padStart(2, '0')}`;

            matches.forEach(match => {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'matched-day';
                if (selectedMatchedDay === match.date) {
                    dayDiv.classList.add('selected');
                }
                
                const eventInfo = match.event 
                    ? `${match.event.type} (${match.event.startTime}-${match.event.endTime}, ${match.event.visibility.min}mi)`
                    : 'Clear conditions';
                
                const visibilityInfo = match.visibility !== null && match.visibility !== undefined
                    ? `${match.visibility.toFixed(1)} mi at ${match.timeSlot || arrivalSlot}`
                    : 'Unknown';
                
                dayDiv.innerHTML = `
                    <div class="matched-day-header">
                        <span class="matched-day-date">${match.date}</span>
                        <span class="matched-day-score">Match</span>
                    </div>
                    <div class="matched-day-details">
                        <div>${eventInfo}</div>
                        <div style="font-size: 11px; color: #888; margin-top: 4px;">
                            Visibility: ${visibilityInfo} (matched at ${match.timeSlot || arrivalSlot})
                        </div>
                    </div>
                `;
                
                dayDiv.addEventListener('click', () => {
                    selectedMatchedDay = match.date;
                    document.querySelectorAll('.matched-day').forEach(el => el.classList.remove('selected'));
                    dayDiv.classList.add('selected');
                    loadMatchedDayData(match.date);
                });
                
                list.appendChild(dayDiv);
            });
        }

        async function loadVisibilityData(date, airportCode) {
            const [year] = date.split('-');
            try {
                const metarPath = `cache/metar/${airportCode}/${airportCode}_${year}.json`;
                const response = await fetch(metarPath);
                if (!response.ok) {
                    return null;
                }
                const metarData = await response.json();
                if (!metarData || !metarData.records) {
                    return null;
                }

                const season = getSeason(date, airportCode, year);
                const offsets = {
                    KORD: { winter: -6, summer: -5 },
                    KLGA: { winter: -5, summer: -4 },
                    KJFK: { winter: -5, summer: -4 },
                    KLAX: { winter: -8, summer: -7 },
                    KSFO: { winter: -8, summer: -7 },
                };
                const offset = offsets[airportCode] || { winter: -6, summer: -5 };
                const offsetHours = season === 'summer' ? offset.summer : offset.winter;

                const visibilityBySlot = {};

                for (const record of metarData.records) {
                    if (!record.valid || record.visibility_sm_v === null || record.visibility_sm_v === undefined) {
                        continue;
                    }

                    let recordDate;
                    if (typeof record.valid === 'string') {
                        let dateStr = record.valid;
                        if (!dateStr.includes('T')) {
                            dateStr = dateStr.replace(/^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})$/, '$1T$2');
                        }
                        if (!dateStr.endsWith('Z') && !dateStr.includes('+') && !dateStr.includes('-', 10)) {
                            dateStr += 'Z';
                        }
                        recordDate = new Date(dateStr);
                    } else {
                        recordDate = new Date(record.valid);
                    }

                    if (isNaN(recordDate.getTime())) continue;

                    const utcTimestamp = recordDate.getTime();
                    const localTimestamp = utcTimestamp + offsetHours * 3600 * 1000;
                    const localDateObj = new Date(localTimestamp);
                    const recordLocalDateStr = localDateObj.toISOString().split('T')[0];

                    if (recordLocalDateStr !== date) {
                        continue;
                    }

                    const localHours = localDateObj.getUTCHours();
                    const localMinutes = localDateObj.getUTCMinutes();
                    const slotMin = Math.floor(localMinutes / 15) * 15;
                    const slot = `${String(localHours).padStart(2, '0')}:${String(slotMin).padStart(2, '0')}`;

                    if (!visibilityBySlot[slot]) {
                        visibilityBySlot[slot] = [];
                    }
                    visibilityBySlot[slot].push(record.visibility_sm_v);
                }

                const processed = {};
                for (let hour = 0; hour < 24; hour++) {
                    for (let minute = 0; minute < 60; minute += 15) {
                        const slot = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                        const visibilities = visibilityBySlot[slot];
                        if (visibilities && visibilities.length > 0) {
                            processed[slot] = visibilities.reduce((a, b) => a + b, 0) / visibilities.length;
                        } else {
                            processed[slot] = null;
                        }
                    }
                }

                return processed;
            } catch (error) {
                console.warn(`Error loading visibility data for ${date}:`, error);
                return null;
            }
        }

        function renderVisibilityChart(visibilityData, date, arrivalTimeSlot) {
            const container = document.getElementById('visibilityChartContainer');
            if (!visibilityData) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            document.getElementById('visibilityChartTitle').textContent = `Visibility Over Time - ${date}`;

            const timeSlots = Object.keys(visibilityData).sort();
            const visibilities = timeSlots.map(slot => visibilityData[slot]);

            const arrivalSlotIndex = timeSlots.indexOf(arrivalTimeSlot);

            if (visibilityChart) {
                visibilityChart.destroy();
            }

            const ctx = document.getElementById('visibilityChart').getContext('2d');
            
            const chartData = {
                labels: timeSlots,
                datasets: [{
                    label: 'Visibility (miles)',
                    data: visibilities.map((v, i) => ({ x: i, y: v })),
                    borderColor: '#1976d2',
                    backgroundColor: 'rgba(25, 118, 210, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: (ctx) => {
                        const index = ctx.parsed.x;
                        if (arrivalSlotIndex >= 0 && index === arrivalSlotIndex) {
                            return 6;
                        }
                        return visibilities[index] !== null ? 2 : 0;
                    },
                    pointBackgroundColor: (ctx) => {
                        const index = ctx.parsed.x;
                        if (arrivalSlotIndex >= 0 && index === arrivalSlotIndex) {
                            return '#ff5722';
                        }
                        return visibilities[index] !== null ? '#1976d2' : 'transparent';
                    },
                    pointBorderColor: (ctx) => {
                        const index = ctx.parsed.x;
                        if (arrivalSlotIndex >= 0 && index === arrivalSlotIndex) {
                            return '#d84315';
                        }
                        return visibilities[index] !== null ? '#1976d2' : 'transparent';
                    },
                    pointBorderWidth: (ctx) => {
                        const index = ctx.parsed.x;
                        if (arrivalSlotIndex >= 0 && index === arrivalSlotIndex) {
                            return 3;
                        }
                        return visibilities[index] !== null ? 1 : 0;
                    },
                    spanGaps: false
                }]
            };
            
            visibilityChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: (context) => {
                                    const index = context[0].parsed.x;
                                    return timeSlots[index] || '';
                                },
                                label: (context) => {
                                    const value = context.parsed.y;
                                    if (value === null) return 'No data';
                                    return `Visibility: ${value.toFixed(1)} miles`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Visibility (miles)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1);
                                }
                            }
                        },
                        x: {
                            type: 'linear',
                            min: 0,
                            max: timeSlots.length - 1,
                            title: {
                                display: true,
                                text: 'Time (Local)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45,
                                maxTicksLimit: 25,
                                stepSize: 4,
                                callback: function(value, index) {
                                    const slotIndex = Math.round(value);
                                    if (slotIndex >= 0 && slotIndex < timeSlots.length && slotIndex % 4 === 0) {
                                        return timeSlots[slotIndex];
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
            
        }

        async function loadMatchedDayData(date) {
            const airportCode = document.getElementById('airportSelect').value;
            const arrivalTime = document.getElementById('arrivalTime').value;
            const [arrivalHour, arrivalMin] = arrivalTime.split(':').map(Number);
            const arrivalSlot = `${String(arrivalHour).padStart(2, '0')}:${String(Math.floor(arrivalMin / 15) * 15).padStart(2, '0')}`;
            
            const [year, month, day] = date.split('-');
            try {
                const response = await fetch(`cache/${airportCode}/${year}/${month}/l2-stats-${day}.json`);
                if (!response.ok) {
                    console.warn(`L2 stats not available for ${date}`);
                    if (scatterChart) {
                        scatterChart.destroy();
                        scatterChart = null;
                    }
                    document.getElementById('scatterChartTitle').textContent = `No data available for ${date}`;
                    document.getElementById('visibilityChartContainer').style.display = 'none';
                    return;
                }
                const dayData = await response.json();
                renderScatterChart(dayData, date);
                
                const visibilityData = await loadVisibilityData(date, airportCode);
                renderVisibilityChart(visibilityData, date, arrivalSlot);
            } catch (error) {
                console.warn(`Error loading matched day data for ${date}:`, error.message);
                if (scatterChart) {
                    scatterChart.destroy();
                    scatterChart = null;
                }
                document.getElementById('scatterChartTitle').textContent = `Error loading data for ${date}`;
                document.getElementById('visibilityChartContainer').style.display = 'none';
            }
        }

        function getUTCOffsetHoursForDate(airport, dateStr) {
            const season = getSeason(dateStr, airport, dateStr.split('-')[0]);
            const offsets = {
                KORD: { winter: -6, summer: -5 },
                KLGA: { winter: -5, summer: -4 },
                KJFK: { winter: -5, summer: -4 },
                KLAX: { winter: -8, summer: -7 },
                KSFO: { winter: -8, summer: -7 },
            };
            const offset = offsets[airport] || { winter: -6, summer: -5 };
            return season === 'summer' ? offset.summer : offset.winter;
        }

        function convertUTCToLocalTime(utcDate, dateStr, airport, year) {
            const offsetHours = getUTCOffsetHoursForDate(airport, dateStr);
            const offsetMs = offsetHours * 60 * 60 * 1000;
            const localTime = new Date(utcDate.getTime() + offsetMs);
            return localTime;
        }

        const aircraftCategories = {
            small: {
                name: 'Small/Light',
                types: ['C208', 'C25A', 'C25B', 'C310', 'C525', 'C550', 'C560', 'C56X', 'C680', 'C68A', 'C700', 'C750', 'BE20', 'BE40', 'BE9L', 'PC12', 'SF50', 'LJ31', 'LJ35', 'LJ45', 'LJ60', 'CL30', 'CL35', 'CL60', 'E545', 'E550', 'E55P', 'FA20', 'FA50', 'FA7X', 'FA8X', 'F2TH', 'F900', 'G280', 'GA5C', 'GA6C', 'GALX', 'GL5T', 'GL7T', 'GLEX', 'GLF4', 'GLF5', 'GLF6', 'H25B', 'HA4T', 'HDJT', 'B350']
            },
            regional: {
                name: 'Regional',
                types: ['CRJ2', 'CRJ7', 'CRJ9', 'E135', 'E145', 'E170', 'E190', 'E35L', 'E45X', 'E75L', 'E75S', 'BCS1', 'BCS3']
            },
            narrowbody: {
                name: 'Narrow-body',
                types: ['A20N', 'A21N', 'A319', 'A320', 'A321', 'B712', 'B734', 'B737', 'B738', 'B739', 'B38M', 'B39M', 'B752', 'B753']
            },
            widebody: {
                name: 'Wide-body',
                types: ['A306', 'A332', 'A333', 'A339', 'A343', 'A346', 'A359', 'A35K', 'B762', 'B763', 'B772', 'B77L', 'B77W', 'B788', 'B789', 'B78X', 'B744', 'B748', 'MD11']
            },
            other: {
                name: 'Other',
                types: ['AN12', 'C27J', 'UNKNOWN']
            }
        };

        function getAircraftCategory(type) {
            if (!type) return 'other';
            for (const [category, data] of Object.entries(aircraftCategories)) {
                if (data.types.includes(type)) {
                    return category;
                }
            }
            return 'other';
        }

        function renderScatterChart(dayData, date) {
            if (!dayData.overall || !dayData.overall.byTouchdownTimeSlotLocal) {
                return;
            }

            const airportCode = document.getElementById('airportSelect').value;
            const [year] = date.split('-');
            const timeSlots = dayData.overall.byTouchdownTimeSlotLocal;
            const allArrivals = [];

            for (const [slot, slotData] of Object.entries(timeSlots)) {
                const aircraft = slotData.aircraft || [];
                
                for (const ac of aircraft) {
                    if (ac.milestones?.timeFrom50nm !== undefined && ac.touchdown?.utc) {
                        const touchdownTimeUTC = new Date(ac.touchdown.utc);
                        const timeFrom50nmRaw = ac.milestones.timeFrom50nm;
                        const durationMinutes = timeFrom50nmRaw / 60;
                        
                        const touchdownTimeLocal = convertUTCToLocalTime(touchdownTimeUTC, date, airportCode, year);
                        
                        const localHours = touchdownTimeLocal.getUTCHours();
                        const localMinutes = touchdownTimeLocal.getUTCMinutes();
                        const localSeconds = touchdownTimeLocal.getUTCSeconds();
                        const hoursSinceMidnight = localHours + localMinutes / 60 + localSeconds / 3600;
                        
                        const category = getAircraftCategory(ac.type || 'UNKNOWN');
                        
                        allArrivals.push({
                            x: hoursSinceMidnight,
                            y: durationMinutes,
                            icao: ac.icao,
                            type: ac.type || 'UNKNOWN',
                            category: category,
                            touchdownTime: touchdownTimeUTC
                        });
                    }
                }
            }

            if (allArrivals.length === 0) {
                if (scatterChart) {
                    scatterChart.destroy();
                    scatterChart = null;
                }
                document.getElementById('scatterChartTitle').textContent = 'No arrival data available for this day';
                return;
            }

            const colors = {
                small: 'rgba(201, 203, 207, 1)',
                regional: 'rgba(54, 162, 235, 1)',
                narrowbody: 'rgba(255, 159, 64, 1)',
                widebody: 'rgba(75, 192, 192, 1)',
                other: 'rgba(153, 102, 255, 1)'
            };

            const categoryOrder = ['narrowbody', 'widebody', 'regional', 'small', 'other'];
            const datasets = [];
            const categoryData = {};

            categoryOrder.forEach(category => {
                categoryData[category] = allArrivals.filter(arr => arr.category === category);
                if (categoryData[category].length > 0) {
                    const scatterData = categoryData[category].map(arrival => ({
                        x: arrival.x,
                        y: arrival.y,
                        icao: arrival.icao,
                        type: arrival.type,
                        touchdownTime: arrival.touchdownTime
                    }));
                    
                    datasets.push({
                        label: `${aircraftCategories[category].name} (${categoryData[category].length})`,
                        data: scatterData,
                        backgroundColor: colors[category].replace('0.6)', '0.6)'),
                        borderColor: colors[category],
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        category: category,
                        categoryData: categoryData[category]
                    });
                }
            });

            function getSeasonalBaseline(baselineData, dateStr, airport, year) {
                if (!baselineData) {
                    return null;
                }
                
                if (typeof dateStr !== 'string') {
                    console.error('getSeasonalBaseline: dateStr must be a string, got:', typeof dateStr, dateStr);
                    return null;
                }
                
                const season = getSeason(dateStr, airport, year);
                const seasonData = baselineData[season];
                
                if (!seasonData) {
                    return null;
                }
                
                const result = {
                    season: season,
                };
                
                if (seasonData.seasonalTimeSlots) {
                    result.byTimeSlot = seasonData.seasonalTimeSlots;
                } else if (seasonData.byTimeSlotLocal) {
                    result.byTimeSlot = seasonData.byTimeSlotLocal;
                }
                
                if (seasonData.l2Volumes) {
                    result.l2Volumes = seasonData.l2Volumes;
                }
                
                return result;
            }

            const seasonalBaseline = getSeasonalBaseline(currentBaselineData, date, airportCode, year);
            
            if (seasonalBaseline && seasonalBaseline.byTimeSlot) {
                const baselineLineData = [];
                const baselineSlots = Object.keys(seasonalBaseline.byTimeSlot).sort();
                
                baselineSlots.forEach(slot => {
                    const baseline = seasonalBaseline.byTimeSlot[slot];
                    if (baseline && baseline.medianTimeFrom50nm) {
                        const [hours, minutes] = slot.split(':').map(Number);
                        const hourDecimal = hours + minutes / 60;
                        const durationMinutes = baseline.medianTimeFrom50nm / 60;
                        baselineLineData.push({ 
                            x: hourDecimal, 
                            y: durationMinutes,
                            slot: slot
                        });
                    }
                });
                
                if (baselineLineData.length > 0) {
                    const seasonLabel = seasonalBaseline.season === 'summer' ? 'Summer Average' : 'Winter Average';
                    datasets.push({
                        label: seasonLabel,
                        data: baselineLineData,
                        type: 'line',
                        borderColor: 'rgba(0, 0, 0, 1)',
                        backgroundColor: 'rgba(0, 0, 0, 0.1)',
                        borderWidth: 2,
                        borderDash: [10, 5],
                        pointRadius: 2,
                        pointHoverRadius: 4,
                        fill: false,
                        tension: 0.1,
                        showLine: true
                    });
                }
            }

            if (scatterChart) {
                scatterChart.destroy();
            }

            document.getElementById('scatterChartTitle').textContent = `Approach Timings - ${date} (${allArrivals.length} arrivals)`;

            const ctx = document.getElementById('scatterChart').getContext('2d');
            scatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            min: 0,
                            max: 24,
                            title: {
                                display: true,
                                text: 'Touchdown Time (Local Hours)'
                            },
                            ticks: {
                                stepSize: 2
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Time from 50nm to Touchdown (Minutes)'
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: () => '',
                                label: (context) => {
                                    const point = context.raw;
                                    if (!point || point.x === undefined || point.y === undefined) return '';
                                    const dataset = context.dataset;
                                    
                                    if (dataset.type === 'line' && (dataset.label === 'Summer Average' || dataset.label === 'Winter Average')) {
                                        const hours = Math.floor(point.x);
                                        const minutes = Math.floor((point.x - hours) * 60);
                                        return `${dataset.label}: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} - ${point.y.toFixed(1)} min`;
                                    }
                                    
                                    const hours = Math.floor(point.x);
                                    const minutes = Math.floor((point.x - hours) * 60);
                                    const icao = point.icao || 'N/A';
                                    const type = point.type || 'UNKNOWN';
                                    return `${icao} (${type}) - ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')} - ${point.y.toFixed(1)} min`;
                                }
                            }
                        }
                    },
                    onClick: function(event, elements) {
                        if (elements.length > 0) {
                            const element = elements[0];
                            const datasetIndex = element.datasetIndex;
                            const dataIndex = element.index;
                            const chartDatasets = this.data.datasets;
                            const dataset = chartDatasets[datasetIndex];
                            
                            if (dataset && dataset.categoryData && dataset.categoryData[dataIndex]) {
                                const arrival = dataset.categoryData[dataIndex];
                                if (arrival && arrival.touchdownTime) {
                                    showTraceMap(arrival.icao, arrival.type, arrival.touchdownTime, date);
                                }
                            } else if (dataset && dataset.type === 'line') {
                                return;
                            }
                        }
                    }
                }
            });
        }


        function findNearestTimeSlot(timeSlots, targetSlot) {
            if (timeSlots.includes(targetSlot)) {
                return targetSlot;
            }
            
            const [targetHours, targetMinutes] = targetSlot.split(':').map(Number);
            const targetMinutesTotal = targetHours * 60 + targetMinutes;
            
            let nearestSlot = null;
            let minDiff = Infinity;
            
            timeSlots.forEach(slot => {
                const [slotHours, slotMinutes] = slot.split(':').map(Number);
                const slotMinutesTotal = slotHours * 60 + slotMinutes;
                const diff = Math.abs(slotMinutesTotal - targetMinutesTotal);
                
                if (diff < minDiff) {
                    minDiff = diff;
                    nearestSlot = slot;
                }
            });
            
            return nearestSlot;
        }

        function formatTimeSlot(hours, minutes) {
            const h = ((hours % 24) + 24) % 24;
            const m = minutes % 60;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
        }

        function getTimeSlotRange(centerSlot, allTimeSlots, rangeMinutes = 15) {
            if (!allTimeSlots || allTimeSlots.length === 0) {
                return { startSlot: centerSlot, endSlot: centerSlot, centerSlot };
            }
            
            const centerIndex = allTimeSlots.indexOf(centerSlot);
            if (centerIndex === -1) {
                return { startSlot: centerSlot, endSlot: centerSlot, centerSlot };
            }
            
            const slotsPerRange = Math.ceil(rangeMinutes / 15);
            let startIndex = Math.max(0, centerIndex - slotsPerRange);
            let endIndex = Math.min(allTimeSlots.length - 1, centerIndex + slotsPerRange);
            
            return { 
                startSlot: allTimeSlots[startIndex], 
                endSlot: allTimeSlots[endIndex], 
                centerSlot 
            };
        }

        function getSeason(dateStr, airport, year) {
            if (!currentBaselineData || !currentBaselineData.dstDatesByYear) {
                return 'summer';
            }
            
            if (typeof dateStr !== 'string') {
                console.error('getSeason: dateStr must be a string, got:', typeof dateStr, dateStr);
                return 'summer';
            }
            
            const yearStr = typeof year === 'string' ? year : year.toString();
            const dstDates = currentBaselineData.dstDatesByYear[yearStr];
            
            if (!dstDates) {
                return 'summer';
            }
            
            const [dstStartYear, dstStartMonth, dstStartDay] = dstDates.start.split('-').map(Number);
            const [dstEndYear, dstEndMonth, dstEndDay] = dstDates.end.split('-').map(Number);
            const dstStart = new Date(dstStartYear, dstStartMonth - 1, dstStartDay);
            const dstEnd = new Date(dstEndYear, dstEndMonth - 1, dstEndDay);
            
            const [dateYear, dateMonth, dateDay] = dateStr.split('-').map(Number);
            const dateOnly = new Date(dateYear, dateMonth - 1, dateDay);
            const dstStartOnly = new Date(dstStart.getFullYear(), dstStart.getMonth(), dstStart.getDate());
            const dstEndOnly = new Date(dstEnd.getFullYear(), dstEnd.getMonth(), dstEnd.getDate());
            
            if (dateOnly >= dstStartOnly && dateOnly < dstEndOnly) {
                return 'summer';
            }
            return 'winter';
        }

        function getSeasonalAverageData(baselineData, season) {
            const seasonalData = baselineData[season];
            if (!seasonalData || !seasonalData.seasonalTimeSlots) {
                return null;
            }
            
            const timeSlots = Object.keys(seasonalData.seasonalTimeSlots).sort();
            const counts = timeSlots.map(ts => seasonalData.seasonalTimeSlots[ts].averageCount || 0);
            const sampleSizes = timeSlots.map(ts => seasonalData.seasonalTimeSlots[ts].sampleSize?.days || 0);
            
            return { timeSlots, counts, sampleSizes, season };
        }

        function alignTimeSlots(dayTimeSlots, seasonalTimeSlots) {
            const allTimeSlots = [...new Set([...dayTimeSlots, ...seasonalTimeSlots])].sort();
            
            const dayData = new Map();
            dayTimeSlots.forEach((ts, idx) => {
                dayData.set(ts, idx);
            });
            
            const seasonalData = new Map();
            seasonalTimeSlots.forEach((ts, idx) => {
                seasonalData.set(ts, idx);
            });
            
            return {
                alignedTimeSlots: allTimeSlots,
                dayIndices: allTimeSlots.map(ts => dayData.get(ts)),
                seasonalIndices: allTimeSlots.map(ts => seasonalData.get(ts))
            };
        }

        function updateChart(airportCode, date, time) {
            if (!currentBaselineData) {
                console.error('No baseline data loaded');
                return;
            }

            const dateStr = typeof date === 'string' ? date : (date instanceof Date ? date.toISOString().split('T')[0] : String(date));
            const dayOfWeek = getDayOfWeekName(dateStr);
            const timeSlot = getTimeSlotKey(time);
            const dayOfWeekDisplay = dayOfWeek.charAt(0).toUpperCase() + dayOfWeek.slice(1);
            
            const [year] = dateStr.split('-');
            const season = getSeason(dateStr, airportCode, year);
            const seasonDisplay = season.charAt(0).toUpperCase() + season.slice(1);
            
            const dayData = currentBaselineData[season]?.dayOfWeekTimeSlots?.[dayOfWeek];
            
            if (!dayData) {
                console.error(`No data found for ${dayOfWeek} in ${season}`);
                return;
            }

            const dayTimeSlots = Object.keys(dayData).sort();
            const dayCounts = dayTimeSlots.map(ts => dayData[ts].averageCount || 0);
            const daySampleSizes = dayTimeSlots.map(ts => dayData[ts].sampleSize?.days || 0);

            const seasonalAvg = getSeasonalAverageData(currentBaselineData, season);
            if (!seasonalAvg) {
                console.error(`Could not get ${season} seasonal average data`);
                return;
            }

            const alignment = alignTimeSlots(dayTimeSlots, seasonalAvg.timeSlots);
            currentChartAlignment = alignment;
            
            const alignedDayCounts = alignment.alignedTimeSlots.map((ts, idx) => {
                const dayIdx = alignment.dayIndices[idx];
                return dayIdx !== undefined ? dayCounts[dayIdx] : null;
            });
            
            const alignedSeasonalCounts = alignment.alignedTimeSlots.map((ts, idx) => {
                const seasonalIdx = alignment.seasonalIndices[idx];
                return seasonalIdx !== undefined ? seasonalAvg.counts[seasonalIdx] : null;
            });

            const matchedTimeSlot = findNearestTimeSlot(dayTimeSlots, timeSlot);
            const currentTimeSlotIndex = matchedTimeSlot ? alignment.alignedTimeSlots.indexOf(matchedTimeSlot) : -1;
            const currentDayCount = currentTimeSlotIndex >= 0 ? alignedDayCounts[currentTimeSlotIndex] : null;
            const currentSeasonalCount = currentTimeSlotIndex >= 0 ? alignedSeasonalCounts[currentTimeSlotIndex] : null;
            const currentSampleSize = matchedTimeSlot && dayTimeSlots.includes(matchedTimeSlot)
                ? daySampleSizes[dayTimeSlots.indexOf(matchedTimeSlot)] : null;

            if (trafficChart) {
                trafficChart.destroy();
            }

            document.getElementById('chartTitle').textContent = `Aircraft Passing 50nm Threshold - ${dayOfWeekDisplay} vs ${seasonDisplay} Average`;

            const timeSlotRange = matchedTimeSlot ? getTimeSlotRange(matchedTimeSlot, alignment.alignedTimeSlots, 15) : null;
            const startIndex = timeSlotRange ? alignment.alignedTimeSlots.indexOf(timeSlotRange.startSlot) : -1;
            const endIndex = timeSlotRange ? alignment.alignedTimeSlots.indexOf(timeSlotRange.endSlot) : -1;
            const centerIndex = timeSlotRange ? alignment.alignedTimeSlots.indexOf(timeSlotRange.centerSlot) : -1;

            if (!arrivalZonePluginRegistered) {
                Chart.register(arrivalZonePlugin);
                arrivalZonePluginRegistered = true;
            }

            const ctx = document.getElementById('trafficChart').getContext('2d');
            trafficChart = new Chart(ctx, {
                type: 'line',
                plugins: [arrivalZonePlugin],
                data: {
                    labels: alignment.alignedTimeSlots,
                    datasets: [
                        {
                            label: `${dayOfWeekDisplay} Average`,
                            data: alignedDayCounts,
                            borderColor: '#1976d2',
                            backgroundColor: 'rgba(25, 118, 210, 0.1)',
                            borderWidth: 2.5,
                            fill: false,
                            tension: 0.4,
                            pointRadius: currentTimeSlotIndex >= 0 ? (ctx) => {
                                if (alignedDayCounts[ctx.dataIndex] === null) return 0;
                                return ctx.dataIndex === currentTimeSlotIndex ? 8 : 3;
                            } : (ctx) => alignedDayCounts[ctx.dataIndex] === null ? 0 : 3,
                            pointBackgroundColor: currentTimeSlotIndex >= 0 ? (ctx) => {
                                if (alignedDayCounts[ctx.dataIndex] === null) return 'transparent';
                                return ctx.dataIndex === currentTimeSlotIndex ? '#ff5722' : '#1976d2';
                            } : (ctx) => alignedDayCounts[ctx.dataIndex] === null ? 'transparent' : '#1976d2',
                            pointBorderColor: currentTimeSlotIndex >= 0 ? (ctx) => {
                                if (alignedDayCounts[ctx.dataIndex] === null) return 'transparent';
                                return ctx.dataIndex === currentTimeSlotIndex ? '#d84315' : '#1976d2';
                            } : (ctx) => alignedDayCounts[ctx.dataIndex] === null ? 'transparent' : '#1976d2',
                            pointBorderWidth: currentTimeSlotIndex >= 0 ? (ctx) => {
                                if (alignedDayCounts[ctx.dataIndex] === null) return 0;
                                return ctx.dataIndex === currentTimeSlotIndex ? 3 : 1;
                            } : (ctx) => alignedDayCounts[ctx.dataIndex] === null ? 0 : 1,
                            spanGaps: true
                        },
                        {
                            label: `${seasonDisplay} Seasonal Average`,
                            data: alignedSeasonalCounts,
                            borderColor: '#66bb6a',
                            backgroundColor: 'rgba(102, 187, 106, 0.1)',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.4,
                            pointRadius: (ctx) => alignedSeasonalCounts[ctx.dataIndex] !== null ? 2 : 0,
                            pointBackgroundColor: (ctx) => alignedSeasonalCounts[ctx.dataIndex] !== null ? '#66bb6a' : 'transparent',
                            pointBorderColor: (ctx) => alignedSeasonalCounts[ctx.dataIndex] !== null ? '#66bb6a' : 'transparent',
                            spanGaps: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0
                    },
                    transitions: {
                        active: {
                            animation: {
                                duration: 0
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: (context) => {
                                    const value = context.parsed.y;
                                    if (value === null) return null;
                                    const label = `${context.dataset.label}: ${value.toFixed(1)} aircraft`;
                                    
                                    if (context.datasetIndex === 0) {
                                        const dayIdx = alignment.dayIndices[context.dataIndex];
                                        const sampleSize = dayIdx !== undefined ? daySampleSizes[dayIdx] : null;
                                        return sampleSize ? `${label} (${sampleSize} days)` : label;
                                    } else {
                                        const seasonalIdx = alignment.seasonalIndices[context.dataIndex];
                                        const sampleSize = seasonalIdx !== undefined ? seasonalAvg.sampleSizes[seasonalIdx] : null;
                                        return sampleSize ? `${label} (${sampleSize} days)` : label;
                                    }
                                }
                            }
                        },
                        arrivalZone: startIndex >= 0 && endIndex >= 0 && centerIndex >= 0 ? {
                            startIndex,
                            endIndex,
                            centerIndex
                        } : null
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Aircraft Passing 50nm Threshold (Average per Day)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time (Local)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    onClick: (event, elements) => {
                        if (elements.length > 0) {
                            return;
                        }
                        
                        const chart = trafficChart;
                        if (!chart || !currentChartAlignment) return;
                        
                        const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                        const xScale = chart.scales.x;
                        const value = xScale.getValueForPixel(canvasPosition.x);
                        
                        if (value !== null && value !== undefined && isFinite(value)) {
                            const timeSlotIndex = Math.round(value);
                            if (timeSlotIndex >= 0 && timeSlotIndex < currentChartAlignment.alignedTimeSlots.length) {
                                const selectedTimeSlot = currentChartAlignment.alignedTimeSlots[timeSlotIndex];
                                if (selectedTimeSlot) {
                                    updateTimeFromChart(selectedTimeSlot);
                                }
                            }
                        }
                    },
                    onHover: (event, elements) => {
                        const chart = trafficChart;
                        if (!chart) return;
                        
                        const canvas = chart.canvas;
                        if (!canvas) return;
                        
                        if (elements && elements.length > 0) {
                            canvas.style.cursor = 'default';
                        } else {
                            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
                            const xScale = chart.scales.x;
                            const value = xScale.getValueForPixel(canvasPosition.x);
                            
                            if (value !== null && value !== undefined && isFinite(value)) {
                                canvas.style.cursor = 'pointer';
                            } else {
                                canvas.style.cursor = 'default';
                            }
                        }
                    }
                }
            });

            const infoPanel = document.getElementById('infoPanel');
            if (currentDayCount !== null) {
                document.getElementById('dayOfWeek').textContent = `${dayOfWeekDisplay} (${seasonDisplay})`;
                const countText = currentDayCount.toFixed(1);
                const seasonalText = currentSeasonalCount !== null ? ` (${seasonDisplay} avg: ${currentSeasonalCount.toFixed(1)})` : '';
                document.getElementById('expectedCount').textContent = countText + ' aircraft' + seasonalText;
                const timeSlotDisplay = matchedTimeSlot === timeSlot ? timeSlot : `${matchedTimeSlot} (nearest to ${timeSlot})`;
                document.getElementById('timeSlot').textContent = timeSlotDisplay;
                document.getElementById('sampleSize').textContent = `${currentSampleSize} days`;
                document.getElementById('dataPeriod').textContent = currentBaselineData.yearRange || '2024-2025';
                infoPanel.style.display = 'block';
            } else {
                infoPanel.style.display = 'none';
            }
        }

        function sliderValueToTime(sliderValue) {
            const totalMinutes = sliderValue * 15;
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function timeToSliderValue(timeStr) {
            const [hours, minutes] = timeStr.split(':').map(Number);
            const totalMinutes = hours * 60 + minutes;
            return Math.round(totalMinutes / 15);
        }

        function updateTimeFromSlider(sliderValue) {
            const timeStr = sliderValueToTime(sliderValue);
            document.getElementById('arrivalTime').value = timeStr;
            document.getElementById('arrivalTimeDisplay').textContent = timeStr;
            updateView();
        }

        function updateTimeFromChart(timeSlot) {
            const sliderValue = timeToSliderValue(timeSlot);
            document.getElementById('arrivalTimeSlider').value = sliderValue;
            updateTimeFromSlider(sliderValue);
        }

        function setDefaultTime() {
            const now = new Date();
            const sixHoursLater = new Date(now.getTime() + 6 * 60 * 60 * 1000);
            const rounded = roundToNearestQuarterHour(sixHoursLater);
            
            const dateInput = document.getElementById('arrivalDate');
            const timeInput = document.getElementById('arrivalTime');
            const timeStr = formatTime(rounded);
            
            dateInput.value = rounded.toISOString().split('T')[0];
            timeInput.value = timeStr;
            
            const sliderValue = timeToSliderValue(timeStr);
            document.getElementById('arrivalTimeSlider').value = sliderValue;
            document.getElementById('arrivalTimeDisplay').textContent = timeStr;
        }

        async function updateView() {
            const airportCode = document.getElementById('airportSelect').value;
            const dateStr = document.getElementById('arrivalDate').value;
            const timeStr = document.getElementById('arrivalTime').value;

            if (!dateStr || !timeStr) {
                return;
            }

            const sliderValue = timeToSliderValue(timeStr);
            document.getElementById('arrivalTimeSlider').value = sliderValue;
            document.getElementById('arrivalTimeDisplay').textContent = timeStr;

            const [year, month, day] = dateStr.split('-').map(Number);
            const [hours, minutes] = timeStr.split(':').map(Number);
            const date = new Date(year, month - 1, day, hours, minutes);

            if (!currentBaselineData || currentBaselineData.airport !== airportCode) {
                await loadBaselineData(airportCode);
            }
            
            if (!currentWeatherPatterns || currentWeatherPatterns.airport !== airportCode) {
                await loadWeatherPatterns(airportCode);
            }
            
            updateChart(airportCode, dateStr, timeStr);
        }

        document.getElementById('airportSelect').addEventListener('change', updateView);
        document.getElementById('arrivalDate').addEventListener('change', updateView);
        document.getElementById('arrivalTime').addEventListener('change', updateView);
        document.getElementById('arrivalTimeSlider').addEventListener('input', (e) => {
            updateTimeFromSlider(parseInt(e.target.value));
        });
        document.getElementById('weatherScenario').addEventListener('change', (e) => {
            const customGroup = document.getElementById('customWeatherGroup');
            customGroup.style.display = e.target.value === 'custom' ? 'flex' : 'none';
        });
        document.getElementById('findSimilarDays').addEventListener('click', async () => {
            const airportCode = document.getElementById('airportSelect').value;
            const arrivalTime = document.getElementById('arrivalTime').value;
            const weatherScenario = document.getElementById('weatherScenario').value;
            const customVisibility = document.getElementById('customVisibility').value;

            if (!arrivalTime) {
                alert('Please select an arrival time');
                return;
            }

            if (!currentWeatherPatterns || currentWeatherPatterns.airport !== airportCode) {
                await loadWeatherPatterns(airportCode);
            }

            const matches = await findMatchingDays(weatherScenario, arrivalTime, customVisibility);
            if (matches.length === 0) {
                alert('No matching historical days found for this weather scenario and arrival time.');
            }
            displayMatchedDays(matches);
        });

        function getTracePath(icao, timestamp, fallbackToOldFormat = false, useUTCDate = true) {
            const airport = document.getElementById('airportSelect').value;
            let dateObj;
            if (timestamp instanceof Date) {
                dateObj = timestamp;
            } else if (typeof timestamp === 'number') {
                dateObj = new Date(timestamp > 4102444800 ? timestamp : timestamp * 1000);
            } else {
                dateObj = new Date(timestamp);
            }
            
            let year, month, day;
            if (useUTCDate) {
                year = dateObj.getUTCFullYear();
                month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
                day = String(dateObj.getUTCDate()).padStart(2, '0');
            } else {
                year = document.getElementById('arrivalDate').value.split('-')[0];
                month = document.getElementById('arrivalDate').value.split('-')[1];
                day = document.getElementById('arrivalDate').value.split('-')[2];
            }
            
            if (fallbackToOldFormat) {
                return `cache/traces/${airport}/${year}/${month}/${day}/${icao}.json`;
            }
            
            const timestampSeconds = Math.floor(dateObj.getTime() / 1000);
            return `cache/traces/${airport}/${year}/${month}/${day}/${icao}-${timestampSeconds}.json`;
        }

        function closeTraceModal() {
            const modal = document.getElementById('traceModal');
            modal.classList.remove('active');
            if (traceMap) {
                traceMap.remove();
                traceMap = null;
                traceMapLayer = null;
            }
        }

        function showTraceMap(icao, aircraftType, timestamp, dateStr) {
            const modal = document.getElementById('traceModal');
            const loading = document.getElementById('traceLoading');
            const error = document.getElementById('traceError');
            const mapContainer = document.getElementById('traceMap');
            
            modal.classList.add('active');
            loading.style.display = 'block';
            error.style.display = 'none';
            mapContainer.innerHTML = '';
            
            const date = timestamp instanceof Date ? timestamp : new Date(timestamp);
            const dateDisplay = `${date.getUTCFullYear()}-${String(date.getUTCMonth() + 1).padStart(2, '0')}-${String(date.getUTCDate()).padStart(2, '0')}`;
            
            document.getElementById('traceModalTitle').textContent = `Flight Trace: ${icao} (${aircraftType}) - ${dateDisplay}`;
            
            const tracePath = getTracePath(icao, timestamp, false, true);
            
            fetch(tracePath)
                .then(response => {
                    if (!response.ok) {
                        const fallbackPath = getTracePath(icao, timestamp, true, true);
                        return fetch(fallbackPath).then(fallbackResponse => {
                            if (!fallbackResponse.ok) {
                                throw new Error(`Trace not found: ${response.status}`);
                            }
                            return fallbackResponse.json();
                        });
                    }
                    return response.json();
                })
                .then(traceData => {
                    loading.style.display = 'none';
                    renderTraceMap(traceData);
                })
                .catch(err => {
                    loading.style.display = 'none';
                    error.style.display = 'block';
                    error.textContent = `Failed to load trace: ${err.message}`;
                });
        }

        function renderTraceMap(traceData) {
            if (!traceData.points || traceData.points.length === 0) {
                document.getElementById('traceError').style.display = 'block';
                document.getElementById('traceError').textContent = 'No trace points available';
                return;
            }

            const points = traceData.points;
            const latlngs = points.map(p => [p[0], p[1]]);
            
            traceMap = L.map('traceMap');
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: ' OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(traceMap);
            
            const bounds = L.latLngBounds(latlngs);
            
            const minAlt = traceData.metadata?.minAlt || 0;
            const maxAlt = traceData.metadata?.maxAlt || 40000;
            
            function getAltitudeColor(alt) {
                if (minAlt === maxAlt) return '#0066cc';
                const ratio = (alt - minAlt) / (maxAlt - minAlt);
                const r = Math.round(ratio * 255);
                const b = Math.round((1 - ratio) * 255);
                return `rgb(${r}, 0, ${b})`;
            }
            
            const segments = [];
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                const color = getAltitudeColor(p1[2]);
                segments.push({
                    latlngs: [[p1[0], p1[1]], [p2[0], p2[1]]],
                    color: color,
                    alt: p1[2],
                    track: p1[4],
                    timestamp: p1[3]
                });
            }
            
            traceMapLayer = L.layerGroup();
            
            const arrowInterval = Math.max(1, Math.floor(segments.length / 50));
            
            segments.forEach((segment, index) => {
                const polyline = L.polyline(segment.latlngs, {
                    color: segment.color,
                    weight: 3,
                    opacity: 0.7
                });
                
                if (index % arrowInterval === 0 && segment.track !== null && segment.track !== undefined) {
                    const midpoint = [
                        (segment.latlngs[0][0] + segment.latlngs[1][0]) / 2,
                        (segment.latlngs[0][1] + segment.latlngs[1][1]) / 2
                    ];
                    
                    const arrowSize = 16;
                    const svg = `
                        <svg width="${arrowSize}" height="${arrowSize}" viewBox="0 0 16 16">
                            <path d="M 8 2 L 12 8 L 10 8 L 10 14 L 6 14 L 6 8 L 4 8 Z" 
                                  fill="${segment.color}" 
                                  stroke="white" 
                                  stroke-width="1.5" 
                                  stroke-linejoin="round"
                                  transform="rotate(${segment.track} 8 8)"/>
                        </svg>
                    `;
                    
                    const icon = L.divIcon({
                        html: svg,
                        className: 'arrow-icon',
                        iconSize: [arrowSize, arrowSize],
                        iconAnchor: [arrowSize / 2, arrowSize / 2]
                    });
                    
                    L.marker(midpoint, { icon: icon }).addTo(traceMapLayer);
                }
                
                polyline.addTo(traceMapLayer);
            });
            
            traceMapLayer.addTo(traceMap);
            traceMap.fitBounds(bounds, { padding: [20, 20] });
        }

        setDefaultTime();
        updateView();
    </script>
</body>
</html>
